// Generated by Copilot
import React, { createContext, useState, useEffect, useContext, ReactNode } from 'react';
import { Cocktail, CocktailSource, SelectedIngredients } from '../types/cocktail';
import { CocktailService, DEFAULT_COCKTAIL_URLS } from '../services/cocktailService';

interface CocktailContextType {
  cocktails: Cocktail[];
  loading: boolean;
  error: string | null;
  sources: CocktailSource[];
  addSource: (url: string) => void;
  removeSource: (url: string) => void;
  selectedIngredients: SelectedIngredients;
  allIngredients: string[];
  toggleIngredient: (ingredient: string) => void;
  resetSelections: () => void;
  filteredCocktails: Cocktail[];
}

const CocktailContext = createContext<CocktailContextType | undefined>(undefined);

interface CocktailProviderProps {
  children: ReactNode;
}

export const CocktailProvider: React.FC<CocktailProviderProps> = ({ children }) => {
  const [cocktails, setCocktails] = useState<Cocktail[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [sources, setSources] = useState<CocktailSource[]>(
    DEFAULT_COCKTAIL_URLS.map(url => ({ url, isDefault: true }))
  );
  const [selectedIngredients, setSelectedIngredients] = useState<SelectedIngredients>({});
  const [allIngredients, setAllIngredients] = useState<string[]>([]);

  // Fetch cocktails whenever sources change
  useEffect(() => {
    const fetchCocktailData = async () => {
      setLoading(true);
      setError(null);
      
      try {
        const urls = sources.map(source => source.url);
        const cocktailService = CocktailService.getInstance();
        const fetchedCocktails = await cocktailService.fetchAllCocktails(urls);
        
        setCocktails(fetchedCocktails);
        
        // Extract all unique ingredients
        const ingredients = new Set<string>();
        fetchedCocktails.forEach(cocktail => {
          cocktail.ingredients.forEach(ingredient => {
            ingredients.add(ingredient.trim());
          });
        });
        
        setAllIngredients(Array.from(ingredients).sort());
      } catch (err) {
        setError('Failed to fetch cocktail data');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchCocktailData();
  }, [sources]);

  const addSource = (url: string) => {
    if (!sources.some(source => source.url === url)) {
      setSources([...sources, { url, isDefault: false }]);
    }
  };

  const removeSource = (url: string) => {
    setSources(sources.filter(source => source.url !== url || source.isDefault));
  };

  const toggleIngredient = (ingredient: string) => {
    setSelectedIngredients(prev => ({
      ...prev,
      [ingredient]: !prev[ingredient]
    }));
  };

  const resetSelections = () => {
    setSelectedIngredients({});
  };

  // Filter cocktails based on selected ingredients using AND logic
  const filteredCocktails = React.useMemo(() => {
    const selectedIngredientsArray = Object.entries(selectedIngredients)
      .filter(([_, isSelected]) => isSelected)
      .map(([ingredient]) => ingredient);

    if (selectedIngredientsArray.length === 0) {
      return cocktails;
    }

    // Modified to check both ingredients AND cocktail names
    return cocktails.filter(cocktail => 
      selectedIngredientsArray.every(selectedIngredient => {
        // First check if the ingredient matches any of the cocktail's ingredients
        const ingredientMatch = cocktail.ingredients.some(ingredient => 
          ingredient.toLowerCase().includes(selectedIngredient.toLowerCase())
        );
        
        // If ingredient matches, return true immediately
        if (ingredientMatch) return true;
        
        // If not an ingredient match, also check the cocktail name
        // This allows custom text to match cocktail names as well
        const cocktailNameMatch = cocktail.name.toLowerCase().includes(
          selectedIngredient.toLowerCase()
        );
        
        return cocktailNameMatch;
      })
    );
  }, [cocktails, selectedIngredients]);

  return (
    <CocktailContext.Provider
      value={{
        cocktails,
        loading,
        error,
        sources,
        addSource,
        removeSource,
        selectedIngredients,
        allIngredients,
        toggleIngredient,
        resetSelections,
        filteredCocktails
      }}
    >
      {children}
    </CocktailContext.Provider>
  );
};

export const useCocktail = (): CocktailContextType => {
  const context = useContext(CocktailContext);
  if (context === undefined) {
    throw new Error('useCocktail must be used within a CocktailProvider');
  }
  return context;
};